#! /usr/bin/env lua

local posix = require( "posix" )
local exports = {}
local libs_needed = {}

function string:split( sep )
	local sep, fields = sep or "/", {}
	local pattern = string.format( "([^%s]+)", sep )
	self:gsub( pattern, function( c ) fields[#fields+1] = c end )
	return fields
end

local function mkdir( name )
	local sep = "/";
	local build = ""
	for k, d in pairs( name:split( "/" ) ) do
		if d ~= "" then
			build = build .. "/" .. d
			posix.mkdir( build )
		end
	end
end

local function array_concat( ... ) 
    local t = {}
    for n = 1, select( "#", ... ) do
        local arg = select( n, ... )
        if type( arg ) == "table" then
            for _, v in ipairs( arg ) do
                table.insert( t, v )
            end
        else
            table.insert( t, arg )
        end
    end
    return t
end

local function remove_dup_libs( list )
	local tmp = {}
	local newlist = {}
	for i = #list, 1, -1 do
		local v = list[i]
		if tmp[v] == nil then
			tmp[v] = true
			if v ~= nil then
				table.insert( newlist, 1, v )
			end
		end
	end
	return newlist
end

local function command( cmd )
    local f = io.popen( cmd..'; echo "-retcode:$?"' ,'r' )
    local l = f:read( '*a' )
    f:close()
    local i1, i2, ret = l:find( '%-retcode:(%d+)\n$' )
    if i1 > 1 then i1 = i1 - 1 end
    l = l:sub( 1, i1-1 )
    return l, tonumber( ret )
end

local function file_diff( file, text )
	local file, err = io.open( file, "r" )
	if file == nil then
		return true
	end

	local i = 0
	for line in file:lines() do
		i = i + 1
		if line ~= text[i] then
			return true
		end
	end

	return i ~= #text
end

local function near_match( a, b )
	local i, j = 1, 1
	a = a:lower()
	b = b:lower()
	while i <= #a and j <= #b do
		if a:sub( i, i ) == b:sub( j, j ) then
			i = i + 1
			j = j + 1
		elseif a:sub( i, i ) == "_" or a:sub( i, i ) == "-" then
			i = i + 1
		elseif b:sub( j, j ) == "_" or b:sub( j, j ) == "-" then
			j = j + 1
		else
			return false
		end
	end
	while i <= #a do
		if a:sub( i, i ) == '_' and a:sub( i, i ) == '-' then
			i = i + 1
		else
			return false
		end
	end
	while j <= #a do
		if b:sub( j, j ) == '_' and b:sub( j, j ) == '-' then
			j = j + 1
		else
			return false
		end
	end
	return true
end

----------------------------------------
-- Setup the default build type and directory
----------------------------------------
local build_type
local args = { ... }
if #args > 0 then
	build_type = args[1]
end

----------------------------------------
-- Setup basic environment
----------------------------------------
local ninja
source_dir = posix.getcwd()
top_source_dir = source_dir

----------------------------------------
-- Export a symbol to global scope
----------------------------------------
function Export( name, value )
	assert( value, "Nil symbol exported" )
	exports[name] = value
end

----------------------------------------
-- System and machine names
----------------------------------------
local machine
function Machine()
	if machine == nil then
		machine = posix.uname( "%m" )
	end
	return machine
end

local system
function System()
	if system == nil then
		system = posix.uname( "%s" )
	end
	return system
end

----------------------------------------
-- Recurse into a subdirectory
----------------------------------------
function SubDir( dir )
	-- Run the local config file
	if dir == nil then
		dofile( "config.lua" )
	end

	-- Store all of the old stuff
	local env_copy = {}
	for k, v in pairs( _G ) do
		env_copy[k] = v
	end
	local old_file = ninja
	local old_src_dir = source_dir
	local old_bld_dir = build_dir

	-- Create a new environment
	if dir ~= nil then
		source_dir = SourceFile( dir )
		build_dir = BuildFile( dir )
		posix.mkdir( build_dir )
	end

	-- Subninja into a new file
	if dir ~= nil then
		ninja:write( "subninja " .. BuildFile( "build.ninja" ) .. "\n" )
	end

	-- Create the new ninja file
	if dir ~= nil then
		mkdir( build_dir )
		local tmp, err = io.open( BuildFile( "build.ninja" ), "w+" )
		assert( tmp, err )
		ninja = tmp
	end

	-- Load the lua file from the subdirectory
	local newfile, err = loadfile( SourceFile( "build.lua" ), "t", env_copy )
	assert( newfile, err )
	newfile()

	-- Close the ninja file
	ninja:close()

	-- Restore the previous environment
	ninja = old_file
	source_dir = old_src_dir
	build_dir = old_bld_dir

	-- exports
	for k, v in pairs( exports ) do
		_G[k] = v
	end
end

----------------------------------------
-- Recurse but stay in the same directory
----------------------------------------
function SubFile( file )
	-- Store all of the old stuff
	local env_copy = {}
	for k, v in pairs( _G ) do
		env_copy[k] = v
	end
	for k, v in pairs( env ) do
		env_copy[k] = v
	end
	local old_file = ninja

	-- Subninja into a new file
	if ninja then
		ninja:write( "subninja " .. BuildFile( file .. ".ninja" ) .. "\n" )
	end

	-- Create the new ninja file
	local tmp, err = io.open( BuildFile( file .. ".ninja" ), "w+" )
	assert( tmp, err )
	ninja = tmp

	-- Load the lua file from the subdirectory
	local newfile, err = loadfile( SourceFile( file .. ".lua" ), "t", env_copy )
	assert( newfile, err )
	newfile()

	-- Close the ninja file
	ninja:close()

	-- Restore the previous environment
	ninja = old_file
end

----------------------------------------
-- Recurse into a new scope
----------------------------------------
function Scope( file, func )
	-- Store all of the old stuff
	local env_copy = {}
	for k, v in pairs( _G ) do
		env_copy[k] = v
	end
	local old_file = ninja

	-- Subninja into a new file
	if ninja then
		ninja:write( "subninja " .. BuildFile( file .. ".ninja" ) .. "\n" )
	end

	-- Create the new ninja file
	local tmp, err = io.open( BuildFile( file .. ".ninja" ), "w+" )
	assert( tmp, err )
	ninja = tmp

	-- Run the function in the new scope
	func()

	-- Close the ninja file
	ninja:close()

	-- Restore the previous environment
	ninja = old_file
end

----------------------------------------
-- Set a variable
----------------------------------------
function Variable( name, ... )
	assert( ninja, "Invalid build dir" )
	local value = array_concat( ... )
	ninja:write( name .. " =" )
	for k, v in pairs( value ) do
		ninja:write( " " .. v )
	end
	ninja:write( "\n" )
end

----------------------------------------
-- Find an executable
----------------------------------------
function FindExecutable( name, dirs )
	for k, dir in pairs( dirs ) do
		local stat = posix.stat( dir .. "/" .. name )
		if stat ~= nil and stat.type == "regular" then
			return dir .. "/" .. name
		end
	end
	return nil
end

----------------------------------------
-- Find a file recursively
----------------------------------------
function FindFileRecursive( file, dirs )
	for k, dir in pairs( dirs ) do
		local stat = lfs.attributes( dir .. "/" .. file )
		if stat ~= nil and stat.mode == "file" then
			return dir .. "/" .. file
		else
			for d in lfs.dir( dir ) do
				if d ~= "." and d ~= ".." then
					local fname = dir .. "/" .. d
					local stat = lfs.attributes( fname )
					if stat ~= nil and stat.mode == "directory" then
						ret = FindFileRecursive( file, { fname } )
						if ret ~= nil then
							return ret
						end
					end
				end
			end
		end
	end
	return nil
end

----------------------------------------
-- Find a file given a regular expression for the filename
----------------------------------------
function FindFilePattern( pattern, dirs )
	local list = {}
	for k, dir in pairs( dirs ) do
		for f in lfs.dir( dir ) do
			if string.match( f, pattern ) then
				table.insert( list, dir .. "/" .. f )
			end
		end
	end
	if #list == 0 then
		return nil
	elseif #list == 1 then
		return list[1]
	end
	return list
end

----------------------------------------
-- Append to a variable
----------------------------------------
function Append( name, ... )
	assert( ninja, "Invalid build dir" )
	local list = array_concat( ... )
	ninja:write( name .. " = $" .. name )
	for k, v in pairs( list ) do
		ninja:write( " " .. v )
	end
	ninja:write( "\n" )
end

----------------------------------------
-- CXX flags
----------------------------------------
function CXXFlags( ... )
	local flags = array_concat( ... )
	flags = table.concat( flags, " " )
	Append( "cxxflags", flags )
end

----------------------------------------
-- C flags
----------------------------------------
function CFlags( ... )
	local flags = array_concat( ... )
	flags = table.concat( flags, " " )
	Append( "cflags", flags )
end

----------------------------------------
-- Warning flags
----------------------------------------
function Warning( ... )
	local flags = array_concat( ... )
	local str = ""
	for k, warn in pairs( flags ) do
		if warn:match( "^-" ) then
			str = str .. " " .. warn
		else
			str = str .. " -W" .. warn
		end
	end
	Append( "cwarn", str )
	Append( "cxxwarn", str )
end

function CXXWarning( ... )
	local flags = array_concat( ... )
	local str = ""
	for k, warn in pairs( flags ) do
		if warn:match( "^-" ) then
			str = str .. " " .. warn
		else
			str = str .. " -W" .. warn
		end
	end
	Append( "cxxwarn", str )
end

function CWarning( ... )
	local flags = array_concat( ... )
	local str = ""
	for k, warn in pairs( flags ) do
		if warn:match( "^-" ) then
			str = str .. " " .. warn
		else
			str = str .. " -W" .. warn
		end
	end
	Append( "cwarn", str )
end

----------------------------------------
-- LD flags
----------------------------------------
function LDFlags( ... )
	local flags = array_concat( ... )
	flags = table.concat( flags, " " )
	Append( "ldflags", flags )
end

----------------------------------------
-- Include directory
----------------------------------------
function Include( ... )
	local dirs = array_concat( ... )
	local str = ""
	for k, dir in pairs( dirs ) do
		if dir:match( "^-I" ) then
			str = str .. " " .. dir
		else
			str = str .. " -I" .. dir
		end
	end
	Append( "incdirs", str )
end

----------------------------------------
-- Definition
----------------------------------------
function Definition( ... )
	local defs = array_concat( ... )
	local str = ""
	for k, def in pairs( defs ) do
		if def:match( "^-D" ) then
			str = str .. " " .. def
		else
			str = str .. " -D" .. def
		end
	end
	Append( "defs", str )
end

----------------------------------------
-- Construct the filename in the build directory
----------------------------------------
function BuildFile( file )
	if file:match( "^/" ) then
		return file
	end
	return build_dir .. "/" .. file
end

----------------------------------------
-- Construct the filename in the lib directory
----------------------------------------
function LibFile( file )
	if file:match( "^/" ) then
		return file
	end
	return top_build_dir .. "/lib/" .. file
end

----------------------------------------
-- Construct the filename in the lib directory
----------------------------------------
function BinFile( file )
	if file:match( "^/" ) then
		return file
	end
	return top_build_dir .. "/bin/" .. file
end

----------------------------------------
-- Construct the filename in the source directory
----------------------------------------
function SourceFile( file )
	if file:match( "^/" ) then
		return file
	end
	return source_dir .. "/" .. file
end

----------------------------------------
-- Set the build type
----------------------------------------
function DefaultBuildType( name )
	if build_type == nil then
		build_type = name
	end
end
----------------------------------------
-- Set the build directory
----------------------------------------
function BuildDir( name, dir )
	if name == build_type then
		build_dir = posix.getcwd() .. "/" .. dir
		top_build_dir = build_dir
		posix.mkdir( build_dir )
		ninja = io.open( build_dir .. "/build.ninja", "w+" )
		ninja:write( "include " .. SourceFile( "rules.ninja" ) .. "\n" )
		ninja:write( "build always: phony\n" )
		Variable( "builddir", build_dir )
	end
end

----------------------------------------
-- Query the build type
----------------------------------------
function Building( name )
	if build_type == name then
		return true
	end
	return false
end

----------------------------------------
-- Get a list of files in dir matching pattern
----------------------------------------
function Glob( dir, pattern )
	local list = {}
	local d = source_dir
	if dir ~= nil then
		d = d .. "/" .. dir
	end
	for f in lfs.dir( d ) do
		if pattern == nil or string.match( f, pattern ) then
			table.insert( list, f )
		end
	end
	return list
end

function Doxygen( name, config, src, out )
	assert( ninja, "Invalid build dir" )
	ninja:write( "build " .. name .. ": phony " .. BuildFile( out ) .. "\n" )
	ninja:write( "build " .. BuildFile( out ) .. ": doxygen " .. SourceFile( config ) .. " | always\n" )
	ninja:write( "  srcdir = " .. SourceFile( src ) .. "\n" )
end

----------------------------------------
-- Compile a source file
----------------------------------------
function Compile( ... )
	assert( ninja, "Invalid build dir" )
	local srcs = array_concat( ... )
	local ret = {}
	local hdrs = {}
	local incs = {}
	local cpps = {}
	local cs = {}
	local cus = {}
	local mms = {}

	-- sort the file types
	for k, file in pairs( srcs ) do
		if file:match( "[.]cpp$" ) then
			table.insert( cpps, file )
		elseif file:match( "[.]mm$" ) then
			table.insert( mms, file )
		elseif file:match( "[.]c$" ) then
			jtable.insert( cs, file )
		elseif file:match( "[.]cu$" ) then
			table.insert( cus, file )
		elseif file:match( "[.]h$" ) then
			table.insert( hdrs, BuildFile( file ) )
		elseif file:match( "^-I" ) then
			table.insert( incs, file )
		end
	end

	if #hdrs > 0 then
		hdrs = " | " .. table.concat( hdrs, " " )
	else
		hdrs = ""
	end
	if #incs > 0 then
		incs = "  extra_incs = " .. table.concat( incs, " " ) .. "\n"
	else
		incs = nil 
	end

	for k, file in pairs( cpps ) do
		local obj = BuildFile( file:gsub( "[.]cpp$", ".o" ) )
		ninja:write( "build " .. obj .. ": cxx " .. SourceFile( file ) .. hdrs .. "\n" )
		if incs then
			ninja:write( incs )
		end
		table.insert( ret, obj )
	end

	for k, file in pairs( mms ) do
		local obj = BuildFile( file:gsub( "[.]mm$", ".o" ) )
		ninja:write( "build " .. obj .. ": objcxx " .. SourceFile( file ) .. hdrs .. "\n" )
		if incs then
			ninja:write( incs )
		end
		table.insert( ret, obj )
	end

	for k, file in pairs( cs ) do
		local obj = BuildFile( file:gsub( "[.]c$", ".o" ) )
		ninja:write( "build " .. obj .. ": cc " .. SourceFile( file ) .. hdrs .. "\n" )
		if incs then
			ninja:write( incs )
		end
		table.insert( ret, obj )
	end

	for k, file in pairs( cus ) do
		local cpp = BuildFile( file:gsub( "[.]cu$", ".cuda.cpp" ) )
		ninja:write( "build " .. cpp .. ": nvcc " .. SourceFile( file ) .. "\n" )
		local obj = BuildFile( file:gsub( "[.]cu$", ".cuda.o" ) )
		ninja:write( "build " .. obj .. ": cxx " .. cpp .. "\n" )
		table.insert( ret, obj )
	end
	return ret
end

----------------------------------------
-- Create and compile a version file
----------------------------------------
function Version( ver )
	assert( ninja, "Invalid build dir" )
	local name = BuildFile( "_Version.cpp" )
	local text = {
		"const char *VERSION_ID = \"" .. ver .. "\";";
		"const char *BUILD_DATE = __DATE__;";
	}
	if file_diff( name, text ) then
		local file, err = io.open( name, "w+" )
		assert( file, err )
		for i = 1, #text do
			file:write( text[i] )
			file:write( "\n" )
		end
		file:close()
	end
	return name
end

----------------------------------------
-- Link an executable
----------------------------------------
function Executable( name, ... )
	OptExecutable( name, ... )
	ninja:write( "default " .. name .. "\n" )
end

function OptExecutable( name, ... )
	assert( ninja, "Invalid build dir" )
	local file = BinFile( name )
	local objs = array_concat( ... )
	local shared = {}
	local libs = {}
	ninja:write( "build " .. name .. ": phony " .. file .. "\n" )
	ninja:write( "build " .. file .. ": link_exe" )
	for k, obj in pairs( objs ) do
		if obj:match( "[.]o$" ) then
			ninja:write( " " .. BuildFile( obj ) )
		elseif obj:match( "^-" ) then
			table.insert( libs, obj )
		elseif obj:match( "[.]a$" ) then
			ninja:write( " " .. BuildFile( obj ) )
		elseif obj:match( "[.]so$" ) then
			table.insert( shared, BuildFile( obj ) )
			table.insert( libs, BuildFile( obj ) )
		else
			error( "Can't link " .. obj )
		end
	end
	if #shared > 0 then
		ninja:write( " || " )
		ninja:write( table.concat( remove_dup_libs( shared ), " " ) )
	end
	ninja:write( "\n" )
	if #libs > 0 then
		ninja:write( "  libs = " )
		ninja:write( table.concat( remove_dup_libs( libs ), " " ) )
		ninja:write( "\n" )
	end
	return file
end

function SilentLink()
	ninja:write( "  silent_link = 2>/dev/null\n" )
end

----------------------------------------
-- Link a FlexLM executable
----------------------------------------
function FlexLM( name )
	if name then
		name = "lmnew_" .. name .. "/"
	else
		name = ""
	end
	local out = {
		BuildFile( name .. "lm_new.c" ),
		BuildFile( name .. "lmprikey.h" ),
		BuildFile( name .. "lmseeds.h" )
	}
	local bin = BinFile( "lmnewgen" )
	local ins = {}
	if Building( "dist" ) then
		ins = { "always" }
	end
	Run( ins, out, BuildFile( name ), bin, "rmimage", "-o lm_new.c" )
	local obj = Compile( out[1] )
	return obj, { out[2], out[3] }
end

----------------------------------------
-- Link a library to an executable
----------------------------------------
function LinkSharedLibs( ... )
	local libs = array_concat( ... )
	local list = {}
	for k, lib in pairs( libs ) do
		table.insert( list, top_build_dir .. "/lib/lib" .. lib .. ".so" )
		assert( libs_needed[lib], "Missing library " .. lib )
		for i, extra in pairs( libs_needed[lib] ) do
			table.insert( list, extra )
		end
	end
	return remove_dup_libs( list )
end

function LinkStaticLibs( ... )
	local libs = array_concat( ... )
	local list = {}
	for k, lib in pairs( libs ) do
		table.insert( list, top_build_dir .. "/lib/lib" .. lib .. ".a" )
		for i, extra in pairs( libs_needed[lib] ) do
			table.insert( list, extra )
		end
	end
	return remove_dup_libs( list )
end

----------------------------------------
-- Link an external library to an executable
----------------------------------------
function LinkSys( ... )
	local libs = array_concat( ... )
	local list = {}
	for k, lib in pairs( libs ) do
		if lib:match( "^-" ) then
			table.insert( list, lib )
		else
			table.insert( list, "-l" .. lib )
		end
	end
	return list
end

----------------------------------------
-- Link a library
----------------------------------------
function BaseLibrary( name, link_cmd, file, ... )
	assert( ninja, "Invalid build dir" )
	local objs = array_concat( ... )
	ninja:write( "build " .. name .. ": phony " .. file .. "\n" )
	ninja:write( "build " .. file .. ": " .. link_cmd )
	libs_needed[name] = {}
	for k, obj in pairs( objs ) do
		if obj:match( "[.]o$" ) then
			ninja:write( " " .. BuildFile( obj ) )
		elseif obj:match( "[.]so$" ) then
			table.insert( libs_needed[name], obj )
		elseif obj:match( "[.]a$" ) then
			table.insert( libs_needed[name], obj )
		elseif obj:match( "^-" ) then
			table.insert( libs_needed[name], obj )
		else
			error( "Can't link " .. obj )
		end
	end
	ninja:write( "\n" )
	ninja:write( "default " .. name .. "\n" )
	return file
end

function SharedLibrary( name, ... )
	return BaseLibrary( name, "link_shared_lib", LibFile( "lib" .. name .. ".so" ), ... )
end

function StaticLibrary( name, ... )
	return BaseLibrary( name, "link_static_lib", LibFile( "lib" .. name .. ".a" ), ... )
end

----------------------------------------
-- Compile a cuda file
----------------------------------------
function CUDACompile( group, ... )
	assert( ninja, "Invalid build dir" )
	local srcs = array_concat( ... )
	local ret = {}
	local list = {}
	for k, file in pairs( srcs ) do
		local cpp = BuildFile( file:gsub( "[.]cpp$", ".cuda.cpp" ) )
		local obj = BuildFile( cpp:gsub( "[.]cpp$", ".o" ) )
		ninja:write( "build " .. cpp .. ": cuda_rewrite " .. SourceFile( file ) .. "\n" )
		ninja:write( "  cuda_group = " .. group .. "\n" )
		ninja:write( "build " .. obj .. ": cxx " .. cpp .. "\n" )
		table.insert( ret, obj )
		table.insert( list, SourceFile( file ) )
	end

	local obj1 = BuildFile( group .. "_sm_21.o" )
	ninja:write( "build " .. obj1 .. ": cuda_compile " .. table.concat( list, " " ) .. "\n" )
	ninja:write( "  cuda_arch = arch=compute_20,code=sm_21\n" )

	local obj2 = BuildFile( group .. "_sm_20.o" )
	ninja:write( "build " .. obj2 .. ": cuda_compile " .. table.concat( list, " " ) .. "\n" )
	ninja:write( "  cuda_arch = arch=compute_20,code=sm_20\n" )

	local obj3 = BuildFile( group .. "_sm_13.o" )
	ninja:write( "build " .. obj3 .. ": cuda_compile " .. table.concat( list, " " ) .. "\n" )
	ninja:write( "  cuda_arch = arch=compute_13,code=sm_13\n" )

	table.insert( ret, obj1 )
	table.insert( ret, obj2 )
	table.insert( ret, obj3 )

	return ret
end

----------------------------------------
-- Data compiled directly into an object
----------------------------------------
function DataCompile( name, ... )
	assert( ninja, "Invalid build dir" )
	local data = array_concat( ... )
	local text = {}
	local ret = {}
	for k, file in pairs( data ) do
		local symname = name .. "_" .. posix.basename( file ):gsub( "[./]", "_" )
		table.insert( text, "extern char _binary_" .. symname .. "_start;" )
		table.insert( text, "extern char _binary_" .. symname .. "_end;" )
		table.insert( text, "extern int _binary_" .. symname .. "_size;" )
	end
	table.insert( text, "static struct { const char *name; const char *start; const char *end; intptr_t size; } " .. name .. "[] = {" )
	for k, file in pairs( data ) do
		local symname = name .. "_" .. posix.basename( file ):gsub( "[./]", "_" )
		local silly = SourceFile( file ):gsub( "[./]", "_" )
		local obj = BuildFile( file .. ".o" )
		table.insert( text, "{ \"" .. file .. "\", &_binary_" .. symname .. "_start, &_binary_" .. symname .. "_end, (intptr_t)&_binary_" .. symname .. "_size }," )
		ninja:write( "build " .. obj .. ": data_compile " .. SourceFile( file ) .. "\n" )
		local ren = "--redefine-sym _binary_" .. silly .. "_start=_binary_" .. symname .. "_start "
		ren = ren .. "--redefine-sym _binary_" .. silly .. "_end=_binary_" .. symname .. "_end "
		ren = ren .. "--redefine-sym _binary_" .. silly .. "_size=_binary_" .. symname .. "_size "
		ninja:write( "  renames = " .. ren .. "\n" )
		table.insert( ret, obj )
	end
	table.insert( text, "{ 0, 0, 0, 0 } };" )

	local hfile = BuildFile( name .. ".h" )
	if file_diff( hfile, text ) then
		local header = io.open( hfile, "w+" )
		for i = 1, #text do
			header:write( text[i] )
			header:write( "\n" )
		end
		header:close()
	end
	return ret
end

----------------------------------------
-- Lua compiled directly into an object
----------------------------------------
function LuaCompile( name, ... )
	assert( ninja, "Invalid build dir" )
	local scripts = array_concat( ... )
	local ret = {}
	for k, script in pairs( scripts ) do
		local obj = BuildFile( script .. "o" )
		ninja:write( "build " .. obj .. ": luac " .. SourceFile( script ) .. "\n" )
		table.insert( ret, obj )
	end

	return DataCompile( name, ret )
end

----------------------------------------
-- Run a command that generates files
----------------------------------------
function Run( input, output, dir, cmd, ... )
	assert( ninja, "Invalid build dir" )
	input = array_concat( input )
	output = array_concat( output )
	ninja:write( "build" )
	for k, o in pairs( output ) do
		ninja:write( " " .. o )
	end
	ninja:write( ": run" )
	for k, i in pairs( input ) do
		ninja:write( " " .. i )
	end
	ninja:write( " | " .. cmd ..  "\n" )
	ninja:write( "  dir = " .. dir .. "\n" )
	ninja:write( "  cmd = " .. cmd .. "\n" )
	ninja:write( "  args =" )
	local args = array_concat( ... )
	for k, arg in pairs( args ) do
		ninja:write( " " .. arg )
	end
	ninja:write( "\n" )
	return output
end

----------------------------------------
-- Find package
----------------------------------------
function Package( ... )
	local libs = array_concat( ... )
	if System() == "Linux" then
		libs = table.concat( libs, " " )

		local cflags, err = command( "pkg-config --cflags-only-other " .. libs )
		assert( err == 0, cflags )

		local iflags, err = command( "pkg-config --cflags-only-I " .. libs )
		assert( err == 0, iflags )

		local lflags, err = command( "pkg-config --libs " .. libs )
		assert( err == 0, lflags )

		return cflags, iflags, lflags
	elseif System() == "Darwin" then
		local iflags = {}
		local lflags = {}
		local found = {}
		local dirlist = array_concat( posix.glob( "/Library/Frameworks/*.framework" ) )
		for j, lib in pairs( libs ) do
			local found = false
			for i, dir in pairs( dirlist ) do
				local fmwk = dir:match( ".*/([^/]*).framework" )
				if near_match( lib, fmwk ) then
					table.insert( iflags, "-I" .. dir .. "/Headers" )
					table.insert( lflags, "-framework " .. fmwk )
					found = true
					break
				end
			end
			assert( found, "Framework " .. lib .. " not found" )
		end
		return "", table.concat( iflags, " " ), table.concat( lflags, " " )
	end
end


----------------------------------------
-- Qt header file processing
----------------------------------------
function QtHeader( ... )
	local hdrs = array_concat( ... )
	assert( hdrs and #hdrs > 0, "No headers" )
	local ret = {}
	for k, hdr in pairs( hdrs ) do
		local out = BuildFile( hdr:gsub( "[.]h$", ".moc.cpp" ) )
		ninja:write( "build " .. out .. ": moc " .. SourceFile( hdr ) .. "\n" )
		table.insert( ret, out )
	end
	return ret
end

----------------------------------------
-- Qt resource file processing
----------------------------------------
function QtResource( name, ...  )
	local qrcs = array_concat( ... )
	local ret = {}
	for k, qrc in pairs( qrcs ) do
		local deps = ""
		local file, err = io.open( SourceFile( qrc ), "r" )
		assert( file, err )
		for line in file:lines() do
			local f = line:match( "<file[^>]*>(.*)</file>" )
			if f then
				deps = deps .. " " .. SourceFile( f )
			end
		end

		local out = BuildFile( qrc .. ".cpp" )
		ninja:write( "build " .. out .. ": rcc " .. SourceFile( qrc ) .. " | " .. deps .. "\n" )
		ninja:write( "  name = " .. name .. "\n" )
		table.insert( ret, out )
	end
	return ret
end

----------------------------------------
-- Flatten everything into a single list
----------------------------------------
function Flatten( ... )
	return array_concat( ... )
end

----------------------------------------
-- Start the whole process
----------------------------------------
SubDir()

