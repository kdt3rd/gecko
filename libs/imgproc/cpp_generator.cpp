
#include "cpp_generator.h"
#include "variable.h"
#include <utf/utf.h>

namespace imgproc
{

////////////////////////////////////////

cpp_generator::cpp_generator( std::ostream &cpp )
	: _cpp( cpp )
{
	_globals = std::make_shared<scope>();
	_globals->set_compile( [&]( const std::shared_ptr<func> &f, const std::vector<data_type> &args ) { return this->compile( f, args ); } );

	// Add default stuff
	_cpp << "// Generated by imgc\n";
	_cpp << "#include <imgproc/buffer.h>\n";
	_cpp << "#include <cmath>\n";
	_cpp << "using namespace imgproc;\n";
	_cpp << "float clamp( float x, float mn, float mx ) { return std::max( std::min( x, mx ), mn ); }\n";

	// Add built-in functions
	_globals->add_function( U"floor", std::make_shared<func>( U"std::floor", U"x" ) );
	_globals->add_function( U"ceil", std::make_shared<func>( U"std::ceil", U"x" ) );
	_globals->add_function( U"abs", std::make_shared<func>( U"std::fabs", U"x" ) );
	_globals->add_function( U"erf", std::make_shared<func>( U"std::erf", U"x" ) );
	_globals->add_function( U"clamp", std::make_shared<func>( U"clamp", U"x", U"mn", U"mx" ) );
	_globals->add_function( U"array", std::make_shared<func>( U"array" ) );
}

////////////////////////////////////////

void cpp_generator::add_functions( const std::vector<std::shared_ptr<func>> &funcs )
{
	for ( auto f: funcs )
		_globals->add_function( f->name(), f );
}

////////////////////////////////////////

data_type cpp_generator::compile( const std::shared_ptr<func> &f, const std::vector<data_type> &types )
{
	const std::u32string &name = f->name();

	if ( name == U"array" )
	{
		precondition( !types.empty(), "empty array not allowed" );
		return { types.front().base_type(), 1 };
	}

	auto sig = std::make_pair( name, types );
	auto check = _compiled.find( sig );
	if ( check != _compiled.end() )
	{
		if ( check->second.base_type() == pod_type::UNKNOWN )
			throw_runtime( "recursive function {0} not allowed", name );
		return check->second;
	}
	_compiled[sig] = { pod_type::UNKNOWN, 0 };

	std::cout << "Generating " << name << std::endl;
	const auto &args = f->args();
	const auto &mods = f->arg_modifiers();

	precondition( args.size() == types.size(), "expected {0} argument types for function {2}, but got {1}", args.size(), types.size(), name );
	precondition( args.size() == mods.size(), "expected {0} argument modifiers, but got {1}", args.size(), mods.size() );

	if ( !f->result() )
	{
		// Built-in function
		_compiled[sig] = types.front();
		return types.front();
	}

	auto sc = std::make_shared<scope>( _globals );
	for ( size_t a = 0; a < args.size(); ++a )
		sc->add( args[a], types[a] );

	auto t = f->result()->result_type( sc );

	std::ostringstream out;
	compile_context code( out );
	code.line();

	std::stringstream ar;
	for ( size_t a = 0; a < args.size(); ++a )
	{
		if ( a > 0 )
			ar << ", ";
		ar << cpp_type_const_ref( types[a], mods[a] ) << args[a];
	}
	if ( args.empty() )
		ar << "void";
	code.line( "{0} {1}( {2} )", cpp_type( t ), name, ar.str() );
	code.line( "{" );

	code.indent_more();
	std::string res = f->result()->compile( code, sc );
	code.line( "return {0};", res );

	code.indent_less();
	code.line( "}" );

	_cpp << out.str();

	_compiled[sig] = t;
	return t;
}

////////////////////////////////////////

std::shared_ptr<func> cpp_generator::get_function( const std::u32string &name )
{
	auto f = _globals->get_function( name );
	if ( !f )
		throw_runtime( "function \"{0}\" not found", name );
	return f;
}

////////////////////////////////////////

}

